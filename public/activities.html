<!DOCTYPE html>
<html lang="fr">
<head>
    </head>
<body>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // ... (logique fetch inchangée) ...
            fetch(/*...*/)
                .then(/*...*/)
                .then(({ ok, data }) => {
                    // ... (logique inchangée)
                    renderPage(data);
                })
        });

        function renderPage(data) {
            // ... (le début de la fonction est inchangé)
            
            // --- MODIFICATION ICI : On passe aussi le monde Zwift à la fonction renderMap ---
            renderLatestActivity(data.activities, data.latest_activity_map, data.elevation_data, data.zwift_world);

            // ... (le reste de la fonction est inchangé)
        }

        function renderLatestActivity(activities, mapData, chartData, zwiftWorld) {
            // ... (le début de la fonction est inchangé)

            // --- MODIFICATION ICI : On passe le monde Zwift à la fonction renderMap ---
            if (mapData) renderMap(mapData, zwiftWorld);
            
            // ... (le reste de la fonction est inchangé)
        }

        // --- MODIFICATION MAJEURE ICI : La fonction renderMap gère les deux cas ---
        function renderMap(encodedPolyline, zwiftWorld = null) {
            const mapContainer = document.getElementById('map-container');
            mapContainer.innerHTML = '<div id="map"></div>';
            
            try {
                const map = L.map('map');
                
                if (zwiftWorld) {
                    // Si c'est une activité Zwift, on utilise le fond de carte zwiftmap
                    console.log(`Monde Zwift détecté : ${zwiftWorld}`);
                    L.tileLayer('https://api.zwifthacks.com/zwiftmap/tiles/{world}/{z}/{x}/{y}.png', {
                        world: zwiftWorld,
                        attribution: '&copy; <a href="https://zwiftmap.com">ZwiftMap</a>'
                    }).addTo(map);
                } else {
                    // Sinon, on utilise le fond de carte OpenStreetMap par défaut
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>'
                    }).addTo(map);
                }

                const decodedPath = decodePolyline(encodedPolyline);
                if (decodedPath && decodedPath.length > 0) {
                    const polyline = L.polyline(decodedPath, {
                        color: '#fc4c02',
                        weight: 4
                    }).addTo(map);
                    map.fitBounds(polyline.getBounds().pad(0.1));
                }
            } catch (e) {
                console.error("Erreur lors de la création de la carte:", e);
                mapContainer.innerHTML = "<p>Impossible d'afficher la carte.</p>";
            }
        }
        
        // --- Le reste des fonctions est inchangé ---
        const API_URL = "https://projet-strava-api.onrender.com/api/strava"; const statusContainer = document.getElementById('status-container'); const contentWrapper = document.getElementById('content-wrapper'); const stravaCode = new URLSearchParams(window.location.search).get('code');
        function formatDate(d) { return new Date(d).toLocaleDateString('fr-FR', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }); }
        function createStatDetail(icon, label, value, unit = '') { return `<div class="stat-item"><div class="stat-label"><i data-lucide="${icon}"></i>${label}</div><div class="stat-value">${value} <span class="unit">${unit}</span></div></div>`; }
        function formatMovingTime(timeValue) { const totalSeconds = parseInt(timeValue.split(':')[0]) * 3600 + parseInt(timeValue.split(':')[1]) * 60 + parseInt(timeValue.split(':')[2]); const hours = Math.floor(totalSeconds / 3600); const minutes = Math.floor((totalSeconds % 3600) / 60); const seconds = totalSeconds % 60; if (hours > 0) { return `${hours}h ${minutes}min`; } else { return `${minutes}min ${seconds}s`; } }
        function renderChart(d){const c=document.getElementById("chart-container");const x=document.getElementById("elevationChart").getContext("2d");const g=x.createLinearGradient(0,0,0,250);g.addColorStop(0,"rgba(252,76,2,0.4)"),g.addColorStop(1,"rgba(252,76,2,0)");new Chart(x,{type:"line",data:{labels:d.distance.map(v=>(v/1000).toFixed(1)),datasets:[{label:"Altitude (m)",data:d.altitude,borderColor:"#fc4c02",backgroundColor:g,borderWidth:2,pointRadius:0,fill:!0,tension:.3}]},options:{responsive:!0,maintainAspectRatio:!1,scales:{x:{title:{display:!0,text:"Distance (km)"}},y:{title:{display:!0,text:"Altitude (m)"}}},plugins:{legend:{display:!1}}}});}
        function decodePolyline(e){let l=e.length,i=0,a=0,n=0,r=[];while(i<l){let t,h=0,s=0;do{t=e.charCodeAt(i++)-63,s|=(t&31)<<h,h+=5}while(t>=32);let o=s&1?~(s>>1):s>>1;a+=o,h=0,s=0;do{t=e.charCodeAt(i++)-63,s|=(t&31)<<h,h+=5}while(t>=32);let d=s&1?~(s>>1):s>>1;n+=d,r.push([a*1e-5,n*1e-5])}return r}
        function renderHistory(activities){const h=document.getElementById("history-table-body");if(!activities||!activities.length)return;activities.forEach(a=>{const r=document.createElement("tr");r.innerHTML=`<td class="strava-orange">${a.name}</td><td>${(a.distance/1e3).toFixed(2)} km</td><td>${a.total_elevation_gain.toFixed(0)} m</td><td>${new Date(a.start_date_local).toLocaleDateString("fr-FR")}</td>`,h.appendChild(r)})}
    </script>
</body>
</html>